<!DOCTYPE>
<html>

<head>
    <meta charset=utf-8>
    <title>My first three.js app</title>
    <link rel="stylesheet" tpye="text/css" href="./index.css" />
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>

<body>
    <div class="menu">
        <button id="pause" class="button">pause</button>
        <button id="wireframe" class="button">wireframe</button>
        <input type="range" id="radius" name="distance" min="0" max="3" step="any" value="0" oninput="updateRadius(this.value)"/>
        <input type="range" id="radius" name="distance" min="-10" max="10" step="any" value="0" oninput="updateVelocity(this.value)"/>
    </div>
    <script src="js/three.js"></script>
    <script src="js/controls/OrbitControls.js"></script>
    <script>

        let scene = new THREE.Scene();
        let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        let renderer = new THREE.WebGLRenderer();
        let controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.update();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        ///////////////////////
        // CONSTANTS & GLOBAL//
        ///////////////////////
        const magLimit = 3.5; // used to generate percentage to determine tilt
        const heightLimit = .6 // height of cone when not moving around circle
        const initRadius = .25 // initial radius of cone

        let paused = false;
        let wire = true;
        let distance = 0;
        let velocity = 0;

        /////////
        // DOM //
        /////////
        let pauseButton = document.getElementById('pause');
        let wireframeSwitch = document.getElementById('wireframe');

        pauseButton.addEventListener('click', (e) => {
            paused = !paused;
        });

        wireframeSwitch.addEventListener('click', (e) => {
            wire = !wire;
        })

        updateRadius = (value) => {
            distance = value;
        }

        updateVelocity = (value) => {
            velocity = value;
        }

        /////////////
        // HELPERS //
        /////////////
        let xAxis = new THREE.Vector3(1, 0, 0);
        let rotWorldMatrix;     
        rotateAroundWorldAxis = (object, axis, radians) => {
            rotWorldMatrix = new THREE.Matrix4();
            rotWorldMatrix.makeRotationAxis(axis.normalize(), radians);

            // old code for Three.JS pre r54:
            //  rotWorldMatrix.multiply(object.matrix);
            // new code for Three.JS r55+:
            rotWorldMatrix.multiply(object.matrix);                // pre-multiply

            object.matrix = rotWorldMatrix;

            // old code for Three.js pre r49:
            // object.rotation.getRotationFromMatrix(object.matrix, object.scale);
            // old code for Three.js pre r59:
            // object.rotation.setEulerFromRotationMatrix(object.matrix);
            // code for r59+:
            object.rotation.setFromRotationMatrix(object.matrix);
        }
        
        generateCircle = (radius, color) => {
            let circleGeometry = new THREE.CircleGeometry(radius, 90);
            let circleEdges = new THREE.EdgesGeometry(circleGeometry);
            let circle = new THREE.LineSegments(circleEdges, new THREE.LineBasicMaterial({ color: color }));
            scene.add(circle);
            rotateAroundWorldAxis(circle, xAxis, Math.PI / 2);
        }

        generateLine = (start, end) => {
            let lineMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff
            });
            let lineGeometry = new THREE.Geometry();
            lineGeometry.vertices.push(
                new THREE.Vector3(start.x, start.y, start.z),
                new THREE.Vector3(end.x, end.y, end.z)
            );
            let line = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(line);
        }

        generateLightCone = (color, flipped) => {
            let cone;
            let coneGeometry = new THREE.ConeGeometry(initRadius, heightLimit, 32, true);
            let coneEdges = new THREE.EdgesGeometry(coneGeometry);
            let coneMaterial = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.9 });
            wire ? cone = new THREE.LineSegments(coneEdges, new THREE.LineBasicMaterial({ color: color })) : cone = new THREE.Mesh(coneGeometry, coneMaterial);
            if (!flipped) {
                cone.position.y += 0.3;
                rotateAroundWorldAxis(cone, xAxis, Math.PI);
            } else {
                cone.position.y -= 0.3;
                console.log(cone.position)
            }
            scene.add(cone);
            return cone;
        }

        rotating = (object, magnitude, flipped) => {
            const scalePercentage = magnitude / magLimit;
            
            object.scale.set(1 * (1 + scalePercentage), 1 * (1 - scalePercentage), 1 * (1 + scalePercentage))
            
            if (!flipped) {
                object.position.x = (magnitude) * Math.cos(time) + 0;
                object.position.z = (magnitude) * Math.sin(time) + 0;
                object.rotation.y = time + 1.5; // rotates around the circle plane
                object.rotation.z = scalePercentage * (Math.PI / 2) // main tilt of light cone
                object.position.y = Math.cos(object.rotation.z) * .3; // applies appropriate height to cone
            }
            // object.position.y += 0.001;
        }

        //////////
        // LINE //
        //////////
        generateLine({x: -3.5, y: 0, z: 0}, {x: 3.5, y: 0, z: 0})
        generateLine({x: 0, y: -3.5, z: 0}, {x: 0, y: 3.5, z: 0})
        generateLine({x: 0, y: 0, z: -3.5}, {x: 0, y: 0, z: 3.5})

        ////////////
        // CIRCLE //
        ////////////
        generateCircle(3, 0xffffff);
        generateCircle(2, 0xffffff);
        generateCircle(1, 0xffffff);

        //////////
        // CONE //
        //////////
        let futureCone = generateLightCone(0xffff00);
        let pastCone = generateLightCone(0x0000ff, 'past');
    
        ////////////
        // CAMERA //
        ////////////
        camera.position.x = 3.24;
        camera.position.y = 2.13;
        camera.position.z = 3.73;

        let time = 0;
        let animate = () => {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            // console.log(futureCone)
            
            if (!paused) {
                time += 0.01;
                rotating(futureCone, distance);
                rotating(pastCone, distance, 'past');
            }
        }
        animate();
    </script>
</body>

</html>