<!DOCTYPE>
<html>

<head>
    <meta charset=utf-8>
    <title>My first three.js app</title>
    <link rel="stylesheet" tpye="text/css" href="./index.css" />
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>

<body>
    <div class="menu">
        <h2>Controls</h2>
        <button id="pause" class="button">pause</button>
        <button id="wireframe" class="button">wireframe</button>
        <button id="focus" class="button">focus</button>
        <div>
            <input type="checkbox" name="worldline" checked>
            <label for="worldline">worldline</label>
            <input type="checkbox" name="lightcones" checked>
            <label for="lightcones">lightcones</label>
            <input type="checkbox" name="hyperplanes">
            <label for="hyperplanes">hyperplanes</label>
        </div>
        <!-- <label name="radius_label">radius</label>
        <input type="range" id="radius" name="distance" min="0" max="3" step=".1" value="0" oninput="updateRadius(this.value)"/> -->
    </div>
    <div class="menu right">
        <h3>Light Cones</h3>
        <div class="information-image-container"><img class="information-image" src="assets/images/lightcones.png" alt="lightcones"/></div>
        <p>light cones are really important to understanding this universe and any universe focusing on time travel.</p>
        <h3>Worldline</h3>
        <div class="information-image-container"><img class="information-image" src="assets/images/worldline.png" alt="worldline"/></div>
        <p>worldlines are stories that we create as time passes.</p>
        <h3>Hyperplanes</h3>
        <div class="information-image-container"><img class="information-image" src="assets/images/hyperplane.png" alt="hyperplane"/></div>
        <p>hyperplanes are slices of time. this is a great way to think of what has happened at a certain time.</p>
    </div>
    <div id="pause-icon">
        <div class="pause-block"></div>
        <div class="pause-block"></div>
    </div>
    <script src="js/three.js"></script>
    <script src="js/Tween.js"></script>
    <script src="js/controls/OrbitControls.js"></script>
    <script src="js/helpers.js"></script>
    <script>

        let scene = new THREE.Scene();
        let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
        let renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        let controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.update();
        document.body.appendChild(renderer.domElement);

        /***************/
        /** constants **/
        /***************/
        const magLimit = 3.4; // used to generate percentage to determine tilt
        const heightLimit = .6 // height of cone when not moving around circle
        const initRadius = .25 // initial radius of cone
        const MAX_POINTS = 100000; // used to draw wordline
        
        /**********************/
        /** global variables **/
        /**********************/
        let drawCount = 2;
        let paused = false;
        let distance = 0;
        let velocity = 0;
        let incrementTime = 0.01;
        let focused = true;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2(-1000, 1000), INTERSECTED;

        /*********/
        /** dom **/
        /*********/
        let pauseButton = document.getElementById('pause');
        let pauseIcon = document.getElementById('pause-icon')
        let focusOnLightCone = document.getElementById('focus');
        let lightcones = document.querySelector("input[name='lightcones']");
        let drawnWorldline = document.querySelector("input[name='worldline']");
        let hyperplanes = document.querySelector("input[name='hyperplans']");


        pauseButton.addEventListener('click', (e) => {
            paused = !paused;
            if (paused) {
                pauseIcon.style.visibility = 'visible';
                pauseButton.style.backgroundColor = 'white';
                pauseButton.style.color = 'black';
            } else {
                pauseIcon.style.visibility = 'hidden';
                pauseButton.style.backgroundColor = 'black';
                pauseButton.style.color = 'white';
            }
        });

        focusOnLightCone.addEventListener('click', (e) => {
           focused = !focused;
        });

        document.addEventListener('keydown', (e)=> {
            if (e.which == 32) {
                pauseButton.click();
            }
        });

        lightcones.addEventListener('change', (e) => {
            futureCone.visible = e.target.checked;
            pastCone.visible = e.target.checked;
        });

        drawnWorldline.addEventListener('change', (e) => {
            subjectWorldline.visible = e.target.checked;
        });

        updateRadius = (value) => {
            distance = value;
            HELPERS.rotating(futureCone, pastCone, distance);
        }

        onWindowResize = () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', onWindowResize, false);

        onMouseMove = (e) => {
            e.preventDefault();
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = (e.clientY / window.innerHeight) * 2 - 1;
        }
        document.addEventListener('mousemove', onMouseMove, false);

        /************/
        /** shapes **/
        /************/

        // axises
        HELPERS.generateLine({x: -3.5, y: 0, z: 0}, {x: 3.5, y: 0, z: 0})
        HELPERS.generateLine({x: 0, y: 0, z: -3.5}, {x: 0, y: 0, z: 3.5})

        // wordline
        let subjectWorldline = HELPERS.generateWorldline();

        
        // circles
        HELPERS.generateCircle(3, 0xffffff);
        HELPERS.generateCircle(2, 0xffffff);
        HELPERS.generateCircle(1, 0xffffff);

        // base hyperplane
        HELPERS.generateHyperplane(0);

        // light cones
        let futureCone = HELPERS.generateLightCone(0xffff00);
        let pastCone = HELPERS.generateLightCone(0x0000ff, 'past');
    
        // camera
        // camera.position.x = 1.9;
        // camera.rotation.x = -0.37;
        // camera.rotation.y = 0.3;
        // camera.rotation.z = 0.115;
        // camera.position.y = 2.23;
        camera.position.z = 5.73;

        // time
        let time = 0;
        let lastTime = time;

        camera.lookAt(scene.position);
        let animate = () => {
            requestAnimationFrame(animate);

            // Focusing Camera Logic
            HELPERS.cameraLogic(futureCone, focused, controls, camera);
            if (!paused) {
                
                drawCount = (drawCount + 1) % MAX_POINTS;
                subjectWorldline.geometry.setDrawRange(1, drawCount - 4);

                time += incrementTime;
                camera.position.y = futureCone.position.y;
                HELPERS.rotating(futureCone, pastCone, distance, magLimit);
                distance = HELPERS.loopDistance(distance);

                // if (time - lastTime >= .5) {
                //     lastTime = time;
                //     HELPERS.generateHyperplane(time);
                // }
            }
            renderer.render(scene, camera);
        }
        animate();



        // var container;
        //     var camera, scene, raycaster, renderer;
        //     var mouse = new THREE.Vector2(), INTERSECTED;
        //     var radius = 100, theta = 0;
        //     init();
        //     animate();
        //     function init() {
        //         container = document.createElement('div');
        //         document.body.appendChild(container);

        //         camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
        //         scene = new THREE.Scene();
        //         scene.background = new THREE.Color(0xf0f0f0);
        //         // var light = new THREE.DirectionalLight(0xffffff, 1);
        //         // light.position.set(1, 1, 1).normalize();
        //         // scene.add(light);

        //         camera.position.x = 1.9;
        //         camera.rotation.x = -0.37;
        //         camera.rotation.y = 0.3;
        //         camera.rotation.z = 0.115;
        //         camera.position.y = 2.23;
        //         camera.position.z = 5.73;

        //         var geometry = new THREE.ConeGeometry(5, 20);
        //         for (var i = 0; i < 2000; i++) {
        //             var object = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
        //             object.position.x = Math.random() * 800 - 400;
        //             object.position.y = Math.random() * 800 - 400;
        //             object.position.z = Math.random() * 800 - 400;
        //             object.rotation.x = Math.random() * 2 * Math.PI;
        //             object.rotation.y = Math.random() * 2 * Math.PI;
        //             object.rotation.z = Math.random() * 2 * Math.PI;
        //             object.scale.x = Math.random() + 0.5;
        //             object.scale.y = Math.random() + 0.5;
        //             object.scale.z = Math.random() + 0.5;
        //             scene.add(object);
        //         }
        //         geometry.translate(0, -20 / 2, 0);
        //         raycaster = new THREE.Raycaster();
        //         renderer = new THREE.WebGLRenderer();
        //         renderer.setPixelRatio(window.devicePixelRatio);
        //         renderer.setSize(window.innerWidth, window.innerHeight);
        //         container.appendChild(renderer.domElement);
        //         document.addEventListener('mousemove', onDocumentMouseMove, false);
        //     }
        //     function onDocumentMouseMove(event) {
        //         mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        //         mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        //     }
        //     function animate() {
        //         requestAnimationFrame(animate);
        //         render();
        //     }
        //     function render() {
        //         // find intersections
        //         raycaster.setFromCamera(mouse, camera);
        //         var intersects = raycaster.intersectObjects(scene.children);
        //         if (intersects.length > 0) {
        //             if (INTERSECTED != intersects[0].object) {
        //                 console.log(INTERSECTED);
        //                 if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
        //                 INTERSECTED = intersects[0].object;
        //                 INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
        //                 INTERSECTED.material.emissive.setHex(0xff0000);
        //             }
        //         } else {
        //             if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
        //             INTERSECTED = null;
        //         }
        //         renderer.render(scene, camera);
        //     }
    </script>
</body>

</html>