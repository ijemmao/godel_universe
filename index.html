<!DOCTYPE>
<html>

<head>
    <meta charset=utf-8>
    <title>My first three.js app</title>
    <link rel="stylesheet" tpye="text/css" href="./index.css" />
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>

<body>
    <!-- <div class="menu">
        <h2>Controls</h2>
        <button id="pause" class="button">pause</button>
        <button id="wireframe" class="button">wireframe</button>
        <label name="radius_label">radius</label>
        <input type="range" id="radius" name="distance" min="0" max="3" step=".1" value="0" oninput="updateRadius(this.value)"/>
        <label name="velocity_label">velocity</label>
        <input type="range" id="radius" name="distance" min="-10" max="10" step="any" value="0" oninput="updateVelocity(this.value)"/>
        <label name="speed_label">speed</label>
        <input type="range" id="speed" min="0.001" max="0.05" step="any" value="0.01" oninput="updateSpeed(this.value)" />
    </div>
    <div id="pause-icon">
        <div class="pause-block"></div>
        <div class="pause-block"></div>
    </div> -->
    <script src="js/three.js"></script>
    <script src="js/controls/OrbitControls.js"></script>
    <script>

        let scene = new THREE.Scene();
        let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
        let renderer = new THREE.WebGLRenderer();
        let controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.update();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        ///////////////////////
        // CONSTANTS & GLOBAL//
        ///////////////////////
        const magLimit = 3.4; // used to generate percentage to determine tilt
        const heightLimit = .6 // height of cone when not moving around circle
        const initRadius = .25 // initial radius of cone

        let paused = false;
        let wire = false;
        let distance = 0;
        let velocity = 0;
        let incrementTime = 0.01;

        /////////
        // DOM //
        /////////
        // let pauseButton = document.getElementById('pause');
        // let pauseIcon = document.getElementById('pause-icon')
        // let wireframeSwitch = document.getElementById('wireframe');

        // pauseButton.addEventListener('click', (e) => {
        //     paused = !paused;
        //     if (paused) {
        //         pauseIcon.style.visibility = 'visible';
        //         pauseButton.style.backgroundColor = 'white';
        //         pauseButton.style.color = 'black';
        //     } else {
        //         pauseIcon.style.visibility = 'hidden';
        //         pauseButton.style.backgroundColor = 'black';
        //         pauseButton.style.color = 'white';
        //     }
        // });

        // wireframeSwitch.addEventListener('click', (e) => {
        //     wire = !wire;
        // })

        // document.addEventListener('keydown', (e)=> {
        //     if (e.which == 32) {
        //         pauseButton.click();
        //     }
        // })

        // updateRadius = (value) => {
        //     distance = value;
        //     console.log(futureCone.geometry.faces);
        //     rotating(futureCone, distance);
        //     rotating(pastCone, distance, 'past');
        // }

        // updateVelocity = (value) => {
        //     velocity = value;
        // }

        // updateSpeed = (value) => {
        //     incrementTime = parseFloat(value);
        // }

        /////////////
        // HELPERS //
        /////////////
        generateCircle = (radius, color) => {
            let circleGeometry = new THREE.CircleGeometry(radius, 90);
            let circleEdges = new THREE.EdgesGeometry(circleGeometry);
            let circle = new THREE.LineSegments(circleEdges, new THREE.LineBasicMaterial({ color: color }));
            circle.rotateX(Math.PI / 2);
            scene.add(circle);
            return circle;
        }


        generateHyperplane = (time) => {
            for (let i = 1; i <= 3; i++) {
                let cone = generateCircle(i, 0xffffff);
                cone.position.y = time;
            }
        }

        generateLine = (start, end) => {
            let lineMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff
            });
            let lineGeometry = new THREE.Geometry();
            lineGeometry.vertices.push(
                new THREE.Vector3(start.x, start.y, start.z),
                new THREE.Vector3(end.x, end.y, end.z)
            );
            let line = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(line);
        }

        generateLightCone = (color, flipped) => {
            let cone;
            let coneGeometry = new THREE.ConeGeometry(initRadius, heightLimit, 32, true);
            let coneEdges = new THREE.EdgesGeometry(coneGeometry);
            let coneMaterial = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.9 });
            wire ? cone = new THREE.LineSegments(coneEdges, new THREE.LineBasicMaterial({ color: color })) : cone = new THREE.Mesh(coneGeometry, coneMaterial);
            coneGeometry.translate(0, -heightLimit / 2, 0);
            if (!flipped) {
                cone.rotateX(Math.PI)
            }
            scene.add(cone);
            return cone;
        }

        rotating = (object, magnitude, flipped) => {
            const scalePercentage = magnitude / magLimit;
            
            object.scale.set(1 * (1 + scalePercentage), 1 * (1 - scalePercentage + .1), 1 * (1 + scalePercentage))
            
            if (!flipped) {
                object.position.x = (magnitude) * Math.cos(time) + 0;
                object.position.z = (magnitude) * Math.sin(time) + 0;
                object.rotation.y = time + 1.5; // rotates around the circle plane
                object.rotation.z = scalePercentage * (Math.PI / 2) // main tilt of light cone
            } else {
                object.position.x = (magnitude) * Math.cos(time);
                object.position.z = (magnitude) * Math.sin(time);
                object.rotation.y = -time + 1.5; // rotates around the circle plane
                object.rotation.z = scalePercentage * (Math.PI / 2) // main tilt of light cone
            }
            // object.position.y += 0.01;
        }

        //////////
        // LINE //
        //////////
        generateLine({x: -3.5, y: 0, z: 0}, {x: 3.5, y: 0, z: 0})
        generateLine({x: 0, y: -3.5, z: 0}, {x: 0, y: 3.5, z: 0})
        generateLine({x: 0, y: 0, z: -3.5}, {x: 0, y: 0, z: 3.5})

        ////////////
        // CIRCLE //
        ////////////
        generateCircle(3, 0xffffff);
        generateCircle(2, 0xffffff);
        generateCircle(1, 0xffffff);

        ////////////////
        // HYPERPLANE //
        ////////////////
        generateHyperplane(0);

        //////////
        // CONE //
        //////////
        let futureCone = generateLightCone(0xffff00);
        let pastCone = generateLightCone(0x0000ff, 'past');
    
        ////////////
        // CAMERA //
        ////////////
        camera.position.x = 1.9;
        camera.rotation.x = -0.37;
        camera.rotation.y = 0.3;
        camera.rotation.z = 0.115;
        camera.position.y = 2.23;
        camera.position.z = 5.73;

        let time = 0;
        let lastTime = time;
        let animate = () => {
            console.log(camera);
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            
            if (!paused) {
                time += incrementTime;
                console.log(time)
                // console.log(futureCone.geometry.faces);
                rotating(futureCone, distance);
                rotating(pastCone, distance, 'past');
                // if (time - lastTime >= .5) {
                //     lastTime = time;
                //     generateHyperplane(time);
                // }
                // camera.position.y += 0.01;
            }
        }
        animate();
    </script>
</body>

</html>